# Бизнес требования

- Совершать поиск тегов.
- Совершать поиск фраз по тегам.
- Совершать поиск фраз по словам.
- Совершать поиск юзеров по нику.

# Функциональные требования

## 1 Метод search-tags (auth) POST

**Входящие данные**<br/>

```json
{
  "partTag": "пог"
}
```

**Валидация**<br/>
partTag >= 3 символов, <= 25, разрешённые символы a-zA-Z0-9а-яА-Я.,:; _?!+=/'\"*(){}[]-

**Логика метода**<br/>
Сервис ищет теги в таблице tag по partTag и отсылает юзеру найденные теги с их id.
Сортировка - сначала должны идти теги, которые начинаются со значения partTag в порядке убывания популярности, затем
должны идти теги, которые не начинаются со значения partTag в порядке убывания популярности.

**Исходящие данные в случае успеха** <br/>статус 200

```json
{
  "data": {
    "tags": [
      {
        "id": 15,
        "text": "погожий"
      },
      {
        "id": 2,
        "text": "погода"
      },
      {
        "id": 16,
        "text": "непогожий"
      },
      {
        "id": 18,
        "text": "непогода"
      }
    ]
  }
}
```

## 2 Метод search-phrases-by-tag (auth) POST

**Входящие данные**<br/>

```json
{
  "tagId": 3,
  "sort": "RANDOM"
}
```

**Валидация**<br/>
tagId > 0<br/>
sort: RANDOM, TIME_INSERT

**Логика метода**<br/>
Сервис ищет фразы по tagId и возвращает юзеру массив: id фразы, id юзера, ник юзера, текст фразы, время создания фразы,
теги фразы. Сортировка от новых к страрым или случайным образом.

**Исходящие данные в случае успеха** <br/>статус 200

```json
{
  "data": {
    "phrases": [
      {
        "phraseId": 15,
        "userId": 5,
        "nickname": "Some Nickname",
        "text": "Хорошая погода сегодня",
        "timeInsert": "2023-01-03 16:09:15",
        "tags": [
          {
            "id": 2,
            "text": "погода"
          },
          {
            "id": 16,
            "text": "непогожий"
          }
        ],
        "countLikes": 0,
        "comments": [
          {
            "userId": 9,
            "nickname": "арбузо",
            "commentId": 6,
            "text": "вот это великая фраза!",
            "timeInsert": "2022-12-13 14:52:22"
          }
        ]
      },
      {
        "phraseId": 16,
        "userId": 6,
        "nickname": "Some Nickname - 2",
        "text": "Хорошая погода сегодня - 2",
        "timeInsert": "2023-01-03 16:09:15",
        "tags": [
          {
            "id": 1,
            "text": "море"
          },
          {
            "id": 15,
            "text": "погожий"
          }
        ],
        "countLikes": 2,
        "comments": [
          {
            "userId": 1,
            "nickname": "barabashka",
            "commentId": 1,
            "text": "В моем городе тоже отличная погода.",
            "timeInsert": "2023-01-17 11:41:57"
          }
        ]
      }
    ]
  }
}
```

## 3 Метод search-phrases-by-word (auth) POST

**Входящие данные**<br/>

```json
{
  "partWord": "солн",
  "sort": "TIME_INSERT"
}
```

**Валидация**<br/>
partWord >= 3 символов, <= 25, разрешенные символы a-zA-Z0-9а-яА-Я.,:; _?!+=/'\"*(){}[]-<br/>
sort: RANDOM, TIME_INSERT

**Логика метода**<br/>
Сервис ищет фразы по partWord и возвращает юзеру массив: id фразы, id юзера, ник юзера, текст фразы, время создания
фразы,
теги фразы. Сортировка от новых к страрым или случайным образом.

**Исходящие данные в случае успеха** <br/>статус 200

```json
{
  "data": {
    "phrases": [
      {
        "phraseId": 15,
        "userId": 5,
        "nickname": "Some Nickname",
        "text": "Сегодня солнечный день",
        "timeInsert": "2023-01-03 16:09:15",
        "tags": [
          {
            "id": 2,
            "text": "погода"
          },
          {
            "id": 16,
            "text": "солнце"
          }
        ],
        "countLikes": 0,
        "comments": [
          {
            "userId": 9,
            "nickname": "арбузо",
            "commentId": 6,
            "text": "вот это великая фраза!",
            "timeInsert": "2022-12-13 14:52:22"
          }
        ]
      },
      {
        "phraseId": 16,
        "userId": 6,
        "nickname": "Some Nickname - 2",
        "text": "Яркое солнце",
        "timeInsert": "2023-01-03 16:09:15",
        "tags": [
          {
            "id": 16,
            "text": "солнце"
          },
          {
            "id": 15,
            "text": "яркое"
          }
        ],
        "countLikes": 2,
        "comments": [
          {
            "userId": 1,
            "nickname": "barabashka",
            "commentId": 1,
            "text": "В моем городе тоже отличная погода.",
            "timeInsert": "2023-01-17 11:41:57"
          }
        ]
      }
    ]
  }
}
```

## 4 Метод search-users-by-nickname (auth) POST

**Входящие данные**<br/>

```json
{
  "partNickname": "квар"
}
```

**Валидация**<br/>
partNickname >= 3 символов, <= 15, разрешенные символы a-zA-Z0-9а-яА-Я._-<br/>

**Логика метода**</br>
Сервис ищет юзеров по partNickname и возвращает массив ников и id: сортировка - сначала должны идти ники, которые
начинаются со значения partNickname, затем должны идти ники, которые не начинаются со значения partNickname.

**Исходящие данные в случае успеха** <br/>статус 200

```json
{
  "data": [
    {
      "userId": 7,
      "nickname": "квардобль"
    },
    {
      "userId": 9,
      "nickname": "добкварли"
    },
    {
      "userId": 8,
      "nickname": "добликвар"
    }
  ]
}
```